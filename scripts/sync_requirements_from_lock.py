#!/usr/bin/env python3
"""Generate requirements.txt from uv.lock for the Databricks App.

Single source of truth: pyproject.toml (what we need) and uv.lock (resolved versions).
Run after changing deps:  uv lock  &&  uv run python scripts/sync_requirements_from_lock.py
"""

from __future__ import annotations

from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent

# Packages to include in requirements.txt (Databricks App). Order: direct deps first, then transitive.
# psycopg is emitted as psycopg[binary] so the app works without system libpq.
REQUIREMENTS_ORDER = [
    "databricks-sdk",
    "fastapi",
    "uvicorn",
    "pydantic-settings",
    "sqlmodel",
    "psycopg",       # emitted as psycopg[binary] (no system libpq)
    "psycopg-pool",  # pool extra from pyproject.toml psycopg[binary,pool]
    "pydantic",
    "pydantic-core",
    "starlette",
    "sqlalchemy",
    "greenlet",
    "annotated-types",
    "typing-extensions",
    "typing-inspection",
]


def parse_uv_lock() -> dict[str, str]:
    """Read uv.lock and return package name -> version."""
    lock_path = REPO_ROOT / "uv.lock"
    result: dict[str, str] = {}
    name = None
    for line in lock_path.read_text().splitlines():
        line = line.strip()
        if line.startswith("name = "):
            name = line.split("=", 1)[1].strip().strip('"')
        elif name and line.startswith("version = "):
            version = line.split("=", 1)[1].strip().strip('"')
            result[name] = version
            name = None
    return result


def main() -> int:
    lock = parse_uv_lock()
    missing = [p for p in REQUIREMENTS_ORDER if p not in lock]
    if missing:
        print(f"Missing in uv.lock: {missing}. Run: uv lock")
        return 1

    lines = [
        "# Generated by scripts/sync_requirements_from_lock.py â€” do not edit by hand.",
        "# Source: uv.lock (run  uv lock  then  uv run python scripts/sync_requirements_from_lock.py).",
        "# psycopg[binary] for Databricks App (no system libpq).",
        "",
    ]
    for pkg in REQUIREMENTS_ORDER:
        version = lock[pkg]
        if pkg == "psycopg":
            lines.append("psycopg[binary]==" + version)
        else:
            lines.append(f"{pkg}=={version}")

    out_path = REPO_ROOT / "requirements.txt"
    out_path.write_text("\n".join(lines) + "\n")
    print(f"Wrote {len(REQUIREMENTS_ORDER)} packages to {out_path.relative_to(REPO_ROOT)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
